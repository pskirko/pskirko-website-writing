# Front Matter

© 2018-2019 Peter Skirko. All rights reserved.

## Revision History

* 2019/03/10 - Initial commit (grabbed from website).

# What to do and How to do it: A pocket-sized framework for thinking about getting stuff done with code

I don’t know about you, but I like to have conceptual frameworks for thinking
about things. My best thinking is done 1) with a good conceptual framework in
hand, and 2) in written form. The results are more systematic and less prone to
mis-estimation than, say, off-the-cuff thinking just in my head.

My notion of “conceptual framework” is wide. To me, it covers everything from
successively more accurate encapsulations of the laws of the physical world
(relatively, quantum mechanics, etc.), to the idea that 401k plans are a good
idea because they make you save money before it ever hits your bank account,
thus leading you to save more. I’m not drawing a sharp line between thought,
habit, and other dimensions. Neither of these frameworks, physics or 401k
plans, are absolute truths (e.g. relatively and quantum physics are not (yet)
unified, which should be mildly unsettling to the scientifically astute), but
both are quite useful in human endeavors.

As a coder, I’d like to have a similar framework for framing my thoughts on
coding. And this implies it is indirectly a framework for thinking about my
career in coding, since the majority of my coding has, is, and probably will be
done in a professional context, rather than as a hobby.

For a long time, I used to refer to Joel Spolsky’s famous
“[smart and gets thing done](https://www.joelonsoftware.com/2007/06/05/smart-and-gets-things-done/)”
idea, but I don’t like it anymore. For one thing, calling someone “smart”
is a labelling game and should be unnecessary. If the phrase had been “gets
things done, productively, with high quality and craftsmanship”, I’d be more on
board. Anyhow, that ship has sailed.

I’d like to formulate my own framework about coding. I’ve realized that, just
as relativity and quantum physics are two, not one, I already have a few mental
frameworks I bring to bear on coding. The one I’m presenting now is just the
first, and perhaps the most pragmatic.

I call it: What to do and How to do it. It’s short enough and easy to remember.
It goes something like this:

> As a coder (leader/manager or individual contributor), your situational value
> is proportional to your ability and skill in navigating and addressing two
> basic questions:
> 1. What to do
> 2. How to do it

That’s it, really. Of course, the devil’s in the details. And perhaps this
isn’t solely related to coding, but that’s where I’m focusing.

I like to think of what and how as mutually-recursive questions that interlock
seemingly ad infinitum, like a space elevator.

![Space Elevator FTW](https://i1.wp.com/www.pskirko.com/wp-content/uploads/2018/06/space_elevator.jpg)

What answers the how, which then begets more whats, over and over again. For
example:

* What: Build an iOS game
* How: Learn to write objective-c or Swift, then write the game
* What: Learn Swift and iOS app programming
* How: Buy the Big Nerd Ranch books (Swift, iOS) and go to town!
* …

Note that you can keep piling what and how higher and higher, or lower and
lower, as needed. For example:

* What: “Scratch an itch” and write an iOS app just for the heck of it
* How: Build and release an iOS game (conveniently ignoring concerns about
  gaming market saturation in 2018…)
* What: Build an iOS game (continue as above…)

Going higher, the tower of what and how often ends at either material (ca$h
money) and/or existential (purpose, happiness, …) needs or beliefs. Going
lower, the what and how dance can cha-cha all the way down past
“application-level” code to reasoning about assembly language or foundational
computer architecture properties like caching and bus speeds, to even the speed
of light, the constraint on processor speed growth, the amount of heat
generated by chips, etc. How high or low you choose to go is your choice; there
is no right or wrong canned answer to all this.

Think of what and how as the core of this framework; its basic building blocks.
Working outwards, the next key idea is “navigating and addressing” these
questions. Addressing can mean doing, but when combined, “navigating and
addressing” is a wide superset of just doing. As a coder, you often write or
have written much code yourself, individually and with various teams. But as a
team lead or manager, you spend less time directly coding and instead work at
higher levels of abstraction. Going further, as a codebase maintainer, you
might not have even written a majority of the code now in your purview, but you
still coordinate the effort of others (e.g. through pull requests and code
reviews). Addressing is the tactic, navigating is the strategy.

Next up on this journey is the “skill and ability” part. As a coder, you must
develop a myriad of skills — from vim and git, to the programming language you
need or want to use, to the API surface of the essential platform (iOS, React,
Tensorflow, …) and other toolkits, and so on to actually learning how to solve
domain problems, from modeling financial transactions to natural language
understanding, graphics to networking. These technically-oriented skills are
generally balanced out with “people skills”, especially for leads and managers:
knowing how to lead and manage, gain and hold the trust of your team, how to
make tough or unpopular calls, and so on. One subtlety is that it’s equally
important for individual contributors to always-be-expressing these same people
skills, but I‘ll have to explore that idea another time.

Finally on the road outward is “situational value”. That’s a funny term, and I
will keep considering better versions of it, but “situation” is a very
important idea and very hard to copyedit away. It’s many things: the job, the
team, the project, the company, the competition, the history, the outlook, etc.
The situation could mean that finding a single bug, like
[Spectre](https://en.wikipedia.org/wiki/Spectre_%28security_vulnerability%29),
can upend
decades of “progress” in chip and software engineering.

And as for “value”? Well, that’s a can of worms too. Value to your team or
company, or to your project or endeavor (profit, non-profit, etc), or to your
peers or people who depend on you, or how you value spending your time relative
to other opportunities.

That’s it, in a nutshell. I like this framework because it’s scalable. It
scales all the way up, and all the way down (just like
[Scala](https://www.scala-lang.org/)
tries to do as well, as a language). It also scales from individual coders on
their first projects, to leads of large projects, teams, or companies.

There’s a lot to unpack here, so stay tuned for more. Hit me up in the comments
below as needed!
